## QA 指南：前端無法顯示 JSON 資料，即使後端檔案看起來有內容

**問題描述：**
Web 應用的前端介面無法正確顯示來自後端 JSON 檔案的資料列表（例如：訂閱項目、產品列表等），而是顯示「目前沒有項目」、「無法載入資料」或列表保持空白。然而，開發者檢查後端的 JSON 資料檔案時，確認檔案中確實存在多筆有效的資料。

**核心排查思路：**
問題通常出在「前端獲取資料」、「後端提供資料」或「資料在傳輸/處理過程中遺失或被意外修改」的某個環節。需要從前端的使用者介面向後端資料來源逐步追蹤。

---

**一、初步檢查與環境確認 (Sanity Checks)**

1.  **Flask 伺服器是否正常運行？**
    *   確認執行 `flask run` 的終端機沒有明顯的啟動錯誤。
2.  **JSON 資料檔案的即時狀態：**
    *   **手動打開並仔細檢查** 您的 JSON 資料檔案 (例如 `data/subscriptions.json`)。
    *   **確認 (a)** 檔案內容確實是您預期的資料，而非空陣列 `[]` 或已損壞。 **(b)** JSON 格式是否完全正確（可以使用 JSON 格式化工具或 Linter 檢查）。
    *   **注意：** 有時檔案可能在您上次檢查後被應用程式意外修改。
3.  **瀏覽器端問題：**
    *   **強制重新整理 (Hard Refresh)：** 按 `Ctrl+Shift+R` (Windows/Linux) 或 `Cmd+Shift+R` (Mac) 清除瀏覽器快取並重新載入頁面。舊的 JavaScript 或 CSS 快取可能導致問題。
    *   **嘗試無痕模式 (Incognito/Private Mode)：** 排除瀏覽器擴充功能干擾。

---

**二、詳細排查步驟與可能原因**

**步驟 1：檢查前端 JavaScript 的資料獲取與渲染邏輯**

*   **定位點：** 主要的前端 JavaScript 檔案 (例如 `app/static/js/main.js`)。
*   **檢查內容：**
    1.  **API 呼叫：** 前端是如何呼叫後端 API 來獲取資料的？（例如使用 `fetch()`）。確認 API 端點路徑是否正確。
    2.  **資料處理：** 收到 API 回應後，JavaScript 如何處理這些資料？
    3.  **空資料判斷：** 前端是如何判斷「沒有資料」的？（例如檢查 `if (responseData.length === 0)` 或 `if (!responseData)`)。
    4.  **渲染邏輯：** 將資料渲染成 HTML 的部分是否有錯誤？
*   **偵錯手段：**
    *   **瀏覽器開發者工具 (F12)：**
        *   **主控台 (Console)：** 查看是否有任何紅色的 JavaScript 錯誤訊息。這些錯誤可能會中斷後續的資料處理或渲染。
        *   **網路 (Network)：** 找到對應的 API 請求 (例如 `GET /api/subscriptions`)。檢查其：
            *   **狀態碼 (Status Code)：** 是否為 `200 OK`？如果是 `404 Not Found` (API路徑錯誤)、`500 Internal Server Error` (後端錯誤) 或其他錯誤碼，則問題在後端。
            *   **回應 (Response)：** 查看 API 實際回傳的內容。是預期的 JSON 資料，還是空陣列 `[]`，或是錯誤訊息？
    *   在 JavaScript 中使用 `console.log()` 印出從 API 收到的資料，以及在渲染前處理過的資料，確認資料在前端的狀態。
*   **可能原因：**
    *   JavaScript 執行錯誤。
    *   API 端點路徑錯誤。
    *   前端對「空資料」的判斷邏輯不符合 API 實際回傳。
    *   API 確實回傳了空資料或錯誤。

**步驟 2：檢查後端 API 端點的處理邏輯**

*   **定位點：** Flask 路由處理函式 (例如 `app/routes.py` 中的 `@main_bp.route('/api/subscriptions')`)。
*   **檢查內容：**
    1.  該路由函式是否正確地呼叫了模型層 (Model) 或服務層 (Service) 的函式來獲取資料？
    2.  獲取到資料後，是否正確地使用 `jsonify(data)` 將其轉換為 JSON 回應？
*   **偵錯手段：**
    *   在路由函式內部，從模型/服務層獲取資料後，但在 `jsonify` 之前，使用 `current_app.logger.info(f"Data from model: {your_data_variable}")` 或 `current_app.logger.info(f"Number of items from model: {len(your_data_variable)}")` 將資料內容或長度印到 Flask 的日誌中。
*   **可能原因：**
    *   路由函式未正確呼叫資料獲取邏輯。
    *   資料在 `jsonify` 前就已為空或格式錯誤。

**步驟 3：檢查後端模型/服務層的資料讀取邏輯**

*   **定位點：** 負責從檔案或資料庫讀取資料的函式 (例如 `app/models.py` 中的 `get_all_subscriptions()`)。
*   **檢查內容：**
    1.  **檔案路徑：** 如果是從檔案讀取 (如 JSON)，檔案路徑的計算是否正確？（例如使用 `os.path.join()`）。
    2.  **檔案操作：** `open()`, `json.load()` 等操作是否在 `try...except` 區塊中以處理 `FileNotFoundError`, `json.JSONDecodeError` 等異常？
    3.  **錯誤處理：** 發生錯誤時，函式是否回傳了空列表 `[]` 或 `None`，導致上層也收到空資料？
*   **偵錯手段：**
    *   在該函式中，印出正在嘗試讀取的**確切檔案路徑** (`current_app.logger.info(f"Attempting to read from: {ABSOLUTE_FILE_PATH}")`)。
    *   在成功 `json.load(f)` 之後，印出讀取到的資料長度 (`current_app.logger.info(f"Successfully loaded {len(data)} items.")`)。
*   **可能原因：**
    *   檔案路徑計算錯誤，導致 `FileNotFoundError`。
    *   JSON 檔案本身格式損壞，導致 `json.JSONDecodeError`。
    *   檔案權限問題，導致無法讀取。
    *   **檔案在讀取時內容確實為空 (見步驟 5)。**

**步驟 4：確保 Flask 日誌級別設定正確**

*   **問題：** 如果在 Flask 終端機中看不到您加入的 `current_app.logger.info()` 訊息。
*   **定位點：** Flask 應用程式初始化的地方 (通常是 `app/__init__.py` 中的 `create_app()` 函式)。
*   **解決方案：**
    *   匯入 `logging` 模組: `import logging`
    *   在 `create_app()` 中，設定日誌級別: `app.logger.setLevel(logging.INFO)`。 這樣 `INFO` 級別及以上的日誌（`WARNING`, `ERROR`, `CRITICAL`）都會被處理。
*   **原因：** Flask 預設的日誌級別可能高於 `INFO`，導致這些詳細的偵錯訊息被忽略。

**步驟 5：最隱蔽的問題 —— 檔案被意外覆寫或清空**

*   **症狀：** 所有日誌（前端、路由、模型）都指向最終從檔案讀取到的資料是 0 筆，但您在問題發生「之前」或「之後」手動檢查檔案時，發現檔案內容是正確的（例如有10筆資料）。
*   **核心原因：** 應用程式中存在某段邏輯，它會在特定時機（通常是應用程式啟動、模組載入時）**錯誤地判斷資料檔案不存在或不可讀，然後「好心地」建立一個新的空檔案或用空資料覆寫現有檔案。**
*   **可疑程式碼位置：**
    1.  `app/models.py`：檢查是否有類似 `_ensure_data_files_exist()` 這樣的函式，它在模組被Python直譯器載入時就執行（即函式定義後，在檔案頂層範圍內直接呼叫該函式）。
    2.  `app/__init__.py`：在 `create_app()` 函式內部，檢查是否有確保資料檔案存在的邏輯。
    *   這些函式通常包含 `if not os.path.exists(FILE_PATH):` 這樣的判斷，然後在 `if` 區塊內執行 `open(FILE_PATH, 'w')` 並寫入空內容 (例如 `json.dump([], f)` 或 `f.write('[]')`)。
*   **為何 `os.path.exists()` 可能誤判：**
    *   極短暫的檔案系統 I/O 問題。
    *   檔案權限在特定執行上下文中的問題。
    *   路徑解析在某些情況下的細微差異。
*   **解決方案：**
    1.  **定位並修改/移除覆寫邏輯：**
        *   仔細審查上述可疑位置的程式碼。
        *   **移除或徹底註解掉**任何在檔案不存在時就用空內容創建或覆寫檔案的程式碼片段。
        *   理想情況下，初始化資料檔案的邏輯應該是明確的、一次性的操作（例如透過一個專門的 CLI 指令或在首次設定時執行），而不是在每次應用程式啟動時都靜默執行。
    2.  **（除錯時）使用絕對路徑：** 在 `app/models.py` 中，暫時將資料檔案的路徑（如 `SUBSCRIPTIONS_FILE`）硬式編碼 (hardcode) 為作業系統的絕對路徑，以排除任何相對路徑計算錯誤的可能性。完成除錯後記得改回相對路徑以保持可移植性。
    3.  **最關鍵的驗證步驟：**
        *   在進行上述程式碼修改後，**務必再次手動確認您的 JSON 資料檔案確實包含正確的資料，並儲存。**
        *   **完全停止 Flask 伺服器。**
        *   **重新啟動 Flask 伺服器 (`flask run`)。**
        *   檢查前端頁面及終端機日誌。

---

**三、問題解決後的額外檢查 (例如圖片路徑問題)**

*   當主要的資料載入問題解決後，可能會暴露其他次要問題。例如，在我們的案例中，後端日誌顯示了大量圖片請求的 404 錯誤。
*   **檢查點：**
    1.  **資料來源中的路徑：** JSON 檔案中儲存的圖片路徑 (`serviceIcon`) 是否正確？它是絕對路徑、相對於網站根目錄的路徑，還是相對於某個特定靜態資源目錄的路徑？
    2.  **前端建構 URL 的邏輯：** JavaScript (`main.js` 中的 `renderSubscriptionItem`) 是如何根據 `serviceIcon` 的值來建構完整的 `<img>` 標籤的 `src` 屬性的？是否有多餘的目錄層級（例如 `/static/images/images/icon.svg`）？
*   **解決方案：** 調整 JavaScript 中建構圖片 `src` 的邏輯，確保它與 `serviceIcon` 欄位值的約定一致，並能正確指向 `app/static/` 目錄下的資源。

---

**總結與最佳實踐：**

*   **日誌是關鍵：** 在資料流的每個關鍵節點（前端獲取、路由處理、模型讀取）都加入詳細的日誌記錄，可以極大地幫助定位問題。
*   **警惕自動檔案修改：** 對於在應用程式啟動或模組載入時自動修改或創建資料檔案的程式碼要格外小心。這類「便利」功能常常是資料意外遺失的根源。資料初始化應該是明確且受控的過程。
*   **徹底重啟與清除快取：** 修改後端程式碼後，務必完全重啟 Flask 伺服器。修改前端 JavaScript/CSS 後，務必清除瀏覽器快取並強制重新整理。
*   **逐步排除：** 從問題的表象（前端不顯示）開始，一步步往資料的源頭（後端檔案）回溯檢查，不要跳過任何環節。

希望這份指南能對您有所幫助！ 